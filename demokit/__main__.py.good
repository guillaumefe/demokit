#!/usr/bin/env python3

import os
import sys
import subprocess
import socket
import json
import time
from pathlib import Path
from typing import Optional, List, Dict
import http.server
import threading
import click

class Color:
    GREEN = '\033[1;32m'
    RED = '\033[1;31m'
    NC = '\033[0m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[1;34m'

class NoCacheHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')
        self.send_header('Pragma', 'no-cache')
        self.send_header('Expires', '0')
        super().end_headers()

INTERNAL_SERVICES = {}

class DockerManager:
    def is_docker_running(self) -> bool:
        """V√©rifie si Docker est bien lanc√©."""
        try:
            subprocess.run(['docker', 'info'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except subprocess.CalledProcessError:
            return False

    def stop_existing_container(self, app_name: str):
        """Arr√™te et supprime un conteneur s'il existe d√©j√†."""
        try:
            existing_container = subprocess.run(
                ['docker', 'ps', '-q', '-f', f'name={app_name}'],
                stdout=subprocess.PIPE, text=True
            ).stdout.strip()

            if existing_container:
                print(f"{Color.YELLOW}üõë Un conteneur existant {app_name} a √©t√© trouv√©. Suppression en cours...{Color.NC}")
                subprocess.run(['docker', 'rm', '-f', app_name], check=True)
        except subprocess.CalledProcessError as e:
            print(f"{Color.RED}‚ö†Ô∏è  Impossible de supprimer {app_name}: {e}{Color.NC}")

    def deploy_container(self, app_dir: Path, app_name: str, port: int) -> bool:
        """D√©ploie une application dans un conteneur Docker avec tentative de retry et affichage de `docker scout quickview`."""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                print(f"\n{Color.YELLOW}‚û°Ô∏è  D√©ploiement de {app_name} sur le port {port}...{Color.NC}")
                
                # V√©rifie et supprime un conteneur en cours d'ex√©cution si n√©cessaire
                self.stop_existing_container(app_name)

                subprocess.run(['docker', 'build', '-t', app_name, str(app_dir)], check=True)
                subprocess.run([
                    'docker', 'run', '-d', '--rm',
                    '--name', app_name,
                    '-p', f"{port}:80",
                    app_name
                ], check=True)
                
                print(f"{Color.GREEN}‚úÖ {app_name} d√©ploy√© avec succ√®s sur le port {port}{Color.NC}")

                # Ex√©cuter docker scout quickview apr√®s d√©ploiement
                print(f"{Color.BLUE}üîç Analyse de {app_name} avec Docker Scout Quickview...{Color.NC}")
                subprocess.run(['docker', 'scout', 'quickview', app_name])

                return True
            except subprocess.CalledProcessError as e:
                print(f"{Color.RED}‚ùå Erreur lors du d√©ploiement de {app_name} (tentative {attempt+1}/{max_retries}): {e}{Color.NC}")
                time.sleep(5)  # Attente avant retry
        return False

class AppManager:
    def __init__(self):
        self.apps_dir = Path("apps")
        self.docker_manager = DockerManager()
        self.used_ports = set()

    def find_next_available_port(self, start: int = 3000, end: int = 5000) -> Optional[int]:
        for port in range(start, end + 1):
            if port not in self.used_ports:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    if s.connect_ex(('localhost', port)) != 0:
                        return port
        return None

    def deploy_apps(self) -> List[Dict]:
        deployed_apps = []
        if not self.apps_dir.exists():
            print(f"{Color.RED}‚ùå Aucun dossier 'apps' trouv√©.{Color.NC}")
            return deployed_apps

        if not self.docker_manager.is_docker_running():
            print(f"{Color.RED}‚ùå Docker n'est pas lanc√©. Veuillez d√©marrer Docker et r√©essayer.{Color.NC}")
            sys.exit(1)

        queue = []
        for app_info_path in self.apps_dir.rglob('app-info.json'):
            app_dir = app_info_path.parent
            app_name = app_dir.name.lower()
            try:
                with open(app_info_path) as f:
                    app_info = json.load(f)
            except json.JSONDecodeError:
                print(f"{Color.RED}‚ö†Ô∏è  Fichier app-info.json invalide dans {app_dir}{Color.NC}")
                continue

            port = self.find_next_available_port()
            if not port:
                print(f"{Color.RED}‚ùå Pas de port disponible pour {app_name}{Color.NC}")
                continue

            if self.docker_manager.deploy_container(app_dir, app_name, port):
                self.used_ports.add(port)
                deployed_apps.append({
                    "id": app_name,
                    "title": app_info.get('title', 'Sans titre'),
                    "description": app_info.get('description', 'Pas de description'),
                    "port": port,
                    "url": f"http://localhost:{port}"
                })
                INTERNAL_SERVICES[app_name] = port
            else:
                queue.append((app_dir, app_name, port))

        # Retenter les applications en √©chec √† la fin
        for app_dir, app_name, port in queue:
            print(f"{Color.YELLOW}üîÑ Retentative de d√©ploiement pour {app_name}...{Color.NC}")
            if self.docker_manager.deploy_container(app_dir, app_name, port):
                self.used_ports.add(port)
                deployed_apps.append({
                    "id": app_name,
                    "port": port,
                    "url": f"http://localhost:{port}"
                })
                INTERNAL_SERVICES[app_name] = port

        return deployed_apps

    def generate_catalog(self, apps: List[Dict]):
        """G√©n√®re un fichier HTML pour afficher le catalogue des applications d√©ploy√©es."""
        catalog_path = Path("catalog.html")
        with open(catalog_path, "w") as f:
            f.write("<html><head><title>Catalogue des applications</title>\n")
            f.write('<link rel="stylesheet" href="style.css">\n')
            f.write("</head><body>\n<h1>Catalogue des applications</h1>\n<ul>\n")
            for app in apps:
                f.write(f'<li><a href="{app["url"]}">{app["title"]}</a> - {app["description"]}</li>\n')
            f.write("</ul></body></html>\n")

@click.command()
def main():
    global INTERNAL_SERVICES
    app_manager = AppManager()
    apps = app_manager.deploy_apps()
    app_manager.generate_catalog(apps)

    server_address = ("0.0.0.0", 80)
    with http.server.ThreadingHTTPServer(server_address, NoCacheHTTPRequestHandler) as httpd:
        print(f"{Color.GREEN}üåç Proxy inverse d√©marr√© sur le port 80{Color.NC}")
        httpd.serve_forever()

if __name__ == '__main__':
    main()

