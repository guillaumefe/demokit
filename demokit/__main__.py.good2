#!/usr/bin/env python3

import os
import sys
import subprocess
import socket
import json
import time
from pathlib import Path
from typing import Optional, List, Dict
import http.server
import threading
import click
import urllib.request

class Color:
    GREEN = '\033[1;32m'
    RED = '\033[1;31m'
    NC = '\033[0m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[1;34m'
    CYAN = '\033[1;36m'

INTERNAL_SERVICES = {}

class ReverseProxyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """
    Reverse Proxy pour router les requ√™tes vers les conteneurs Docker d√©ploy√©s.
    """
    def do_GET(self):
        if self.path.startswith("/"):
            app_name = self.path.split("/")[1]
            if app_name in INTERNAL_SERVICES:
                target_port = INTERNAL_SERVICES[app_name]
                url = f"http://localhost:{target_port}{self.path[len(app_name)+1:]}"
                
                try:
                    with urllib.request.urlopen(url) as response:
                        self.send_response(response.status)
                        for header in response.headers:
                            self.send_header(header, response.headers[header])
                        self.end_headers()
                        self.wfile.write(response.read())
                    return
                except Exception as e:
                    self.send_error(502, f"Erreur proxy vers {url} : {e}")
                    return

        self.send_error(404, "Page non trouv√©e")

class DockerManager:
    def is_docker_running(self) -> bool:
        """V√©rifie si Docker est bien lanc√©."""
        try:
            subprocess.run(['docker', 'info'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except subprocess.CalledProcessError:
            return False

    def stop_existing_container(self, app_name: str):
        """Arr√™te et supprime un conteneur s'il existe d√©j√†."""
        try:
            existing_container = subprocess.run(
                ['docker', 'ps', '-q', '-f', f'name={app_name}'],
                stdout=subprocess.PIPE, text=True
            ).stdout.strip()

            if existing_container:
                print(f"{Color.YELLOW}üõë Un conteneur existant {app_name} a √©t√© trouv√©. Suppression en cours...{Color.NC}")
                subprocess.run(['docker', 'stop', app_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(['docker', 'rm', '-f', app_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError as e:
            print(f"{Color.RED}‚ö†Ô∏è  Impossible de supprimer {app_name}: {e}{Color.NC}")

    def deploy_container(self, app_dir: Path, app_name: str, port: int) -> bool:
        """D√©ploie une application dans un conteneur Docker avec gestion du conflit de nom"""
        try:
            print(f"\n{Color.YELLOW}‚û°Ô∏è  D√©ploiement de {app_name} sur le port {port}...{Color.NC}")

            # V√©rifie et supprime le conteneur en cas de conflit de nom
            self.stop_existing_container(app_name)

            subprocess.run(['docker', 'build', '-t', app_name, str(app_dir)], check=True)
            subprocess.run([
                'docker', 'run', '-d',
                '--name', app_name,
                '-p', f"{port}:80",
                app_name
            ], check=True)

            print(f"{Color.GREEN}‚úÖ {app_name} d√©ploy√© avec succ√®s sur /{app_name}/{Color.NC}")
            INTERNAL_SERVICES[app_name] = port  # Stocke l'association nom ‚Üí port

            # Ex√©cuter docker scout quickview apr√®s d√©ploiement (ne bloque pas en cas d'erreur)
            print(f"{Color.BLUE}üîç Analyse de {app_name} avec Docker Scout Quickview...{Color.NC}")
            subprocess.run(['docker', 'scout', 'quickview', app_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            return True
        except subprocess.CalledProcessError as e:
            print(f"{Color.RED}‚ùå Erreur lors du d√©ploiement de {app_name}: {e}{Color.NC}")
            return False

class AppManager:
    def __init__(self):
        self.apps_dir = Path("apps")
        self.docker_manager = DockerManager()
        self.used_ports = set()
        self.deployed_apps = []

    def find_next_available_port(self, start: int = 3000, end: int = 5000) -> Optional[int]:
        """Trouve un port disponible pour une nouvelle application"""
        for port in range(start, end + 1):
            if port not in self.used_ports:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    if s.connect_ex(('localhost', port)) != 0:
                        return port
        return None

    def deploy_apps(self) -> List[Dict]:
        """D√©ploie toutes les applications et configure les liens"""
        if not self.apps_dir.exists():
            print(f"{Color.RED}‚ùå Aucun dossier 'apps' trouv√©.{Color.NC}")
            return []

        if not self.docker_manager.is_docker_running():
            print(f"{Color.RED}‚ùå Docker n'est pas lanc√©. Veuillez d√©marrer Docker et r√©essayer.{Color.NC}")
            sys.exit(1)

        for app_info_path in self.apps_dir.rglob('app-info.json'):
            app_dir = app_info_path.parent
            app_name = app_dir.name.lower()
            try:
                with open(app_info_path) as f:
                    app_info = json.load(f)
            except json.JSONDecodeError:
                print(f"{Color.RED}‚ö†Ô∏è  Fichier app-info.json invalide dans {app_dir}{Color.NC}")
                continue

            port = self.find_next_available_port()
            if not port:
                print(f"{Color.RED}‚ùå Pas de port disponible pour {app_name}{Color.NC}")
                continue

            if self.docker_manager.deploy_container(app_dir, app_name, port):
                self.used_ports.add(port)
                self.deployed_apps.append({
                    "id": app_name,
                    "title": app_info.get('title', 'Sans titre'),
                    "description": app_info.get('description', 'Pas de description'),
                    "category": app_info.get('category', 'Autre'),
                    "url": f"/{app_name}/"  # üî• Correction: URL relative au proxy
                })

        return self.deployed_apps

    def generate_catalog(self):
        """Affiche un r√©sum√© des applications d√©ploy√©es"""
        print(f"\n{Color.CYAN}{'='*40}\n‚úÖ D√âPLOIEMENT TERMIN√â ‚úÖ\n{'='*40}{Color.NC}")
        print(f"{Color.GREEN}üìå Serveur accessible √† : {Color.YELLOW}http://localhost{Color.NC}")
        print(f"{Color.GREEN}üìÑ Catalogue des applications : {Color.YELLOW}http://localhost/catalog.html{Color.NC}\n")

        if self.deployed_apps:
            print(f"{Color.CYAN}üîó Liste des applications d√©ploy√©es :{Color.NC}")
            for app in self.deployed_apps:
                print(f"  - {Color.YELLOW}{app['title']}{Color.NC} ‚ûù {Color.BLUE}http://localhost{app['url']}{Color.NC}")
        else:
            print(f"{Color.RED}‚ùå Aucune application n'a √©t√© d√©ploy√©e.{Color.NC}")

@click.command()
def main():
    global INTERNAL_SERVICES
    app_manager = AppManager()
    app_manager.deploy_apps()
    app_manager.generate_catalog()

    server_address = ("0.0.0.0", 80)
    with http.server.ThreadingHTTPServer(server_address, ReverseProxyHTTPRequestHandler) as httpd:
        print(f"{Color.GREEN}üåç Reverse Proxy en √©coute sur le port 80{Color.NC}")
        httpd.serve_forever()

if __name__ == '__main__':
    main()

